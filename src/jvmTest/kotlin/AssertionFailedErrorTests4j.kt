package com.willowtreeapps.opentest4k

import org.junit.Test
import java.io.*
import kotlin.test.assertEquals
import kotlin.test.assertNull
import kotlin.test.assertTrue

class AssertionFailedErrorTests4j {
    @Test fun deserializationOfAssertionFailedErrorWorksForVersion_1_0_0() {
        // Generated using:
        // FileOutputStream outputStream = new FileOutputStream("src/test/resources/AssertionFailedError_serializedVersion_1_0_0.out");
        // serialize(new AssertionFailedError("message", "foo", "bar"), outputStream);
        // outputStream.close();
        val error = deserializeClasspathResource(
            "/AssertionFailedError_serializedVersion_1_0_0.out"
        ) as AssertionFailedError
        assertEquals("message", error.message)
        assertTrue(error.isExpectedDefined)
        assertEquals("foo", error.expected!!.value)
        assertTrue(error.isActualDefined)
        assertEquals("bar", error.actual!!.value)
    }

    @Test fun ephemeralValueIsOmittedFromSerialization() {
        class NonSerializable {
            val guid = "8675309"
        }

        val error = serializeAndDeserialize(
            AssertionFailedError("a message", NonSerializable(), NonSerializable())
        )
        assertEquals("a message", error.message)
        assertTrue(error.isExpectedDefined)
        assertNull(error.expected!!.value)
        assertNull(error.expected!!.ephemeralValue)
        assertTrue(error.isActualDefined)
        assertNull(error.actual!!.value)
        assertNull(error.actual!!.ephemeralValue)
    }
}

private fun deserializeClasspathResource(name: String): Any? {
    val serialized = name.getResourceAsSerialized()
    return deserialize(serialized)
}

fun String.getResourceAsSerialized(): Serialized {
    val inputStream: InputStream = this.javaClass.getResourceAsStream(this)
    inputStream.use {
        return it.readBytes()
    }
}

actual typealias Serialized = ByteArray

actual inline fun <reified T : Any> deserialize(bytes: Serialized): T {
    val `in` = ObjectInputStream(ByteArrayInputStream(bytes))
    @Suppress("UNCHECKED_CAST")
    return `in`.readObject() as T
}

actual fun serialize(`object`: Any): Serialized {
    val byteArrayOutputStream = ByteArrayOutputStream()
    val out = ObjectOutputStream(byteArrayOutputStream)
    out.writeObject(`object`)
    out.flush()
    return byteArrayOutputStream.toByteArray()
}
